<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Word Count Program</title>
<script>
!function(){var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
(function(){function R(a){function d(e){var b=e.charCodeAt(0);if(b!==92)return b;var a=e.charAt(1);return(b=r[a])?b:"0"<=a&&a<="7"?parseInt(e.substring(1),8):a==="u"||a==="x"?parseInt(e.substring(2),16):e.charCodeAt(1)}function g(e){if(e<32)return(e<16?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return e==="\\"||e==="-"||e==="]"||e==="^"?"\\"+e:e}function b(e){var b=e.substring(1,e.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),e=[],a=
b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,f=b.length;a<f;++a){var h=b[a];if(/\\[bdsw]/i.test(h))c.push(h);else{var h=d(h),l;a+2<f&&"-"===b[a+1]?(l=d(b[a+2]),a+=2):l=h;e.push([h,l]);l<65||h>122||(l<65||h>90||e.push([Math.max(65,h)|32,Math.min(l,90)|32]),l<97||h>122||e.push([Math.max(97,h)&-33,Math.min(l,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});b=[];f=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=f[1]+1?f[1]=Math.max(f[1],h[1]):b.push(f=h);for(a=0;a<b.length;++a)h=b[a],c.push(g(h[0])),
h[1]>h[0]&&(h[1]+1>h[0]&&c.push("-"),c.push(g(h[1])));c.push("]");return c.join("")}function s(e){for(var a=e.source.match(/\[(?:[^\\\] ]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),c=a.length,d=[],f=0,h=0;f<c;++f){var l=a[f];l==="("?++h:"\\"===l.charAt(0)&&(l=+l.substring(1))&&(l<=h?d[l]=-1:a[f]=g(l))}for(f=1;f<d.length;++f)-1===d[f]&&(d[f]=++x);for(h=f=0;f<c;++f)l=a[f],l==="("?(++h,d[h]||(a[f]="(?:")):"\\"===l.charAt(0)&&(l=+l.substring(1))&&l<=h&&
(a[f]="\\"+d[l]);for(f=0;f<c;++f)"^"===a[f]&&"^"!==a[f+1]&&(a[f]="");if(e.ignoreCase&&m)for(f=0;f<c;++f)l=a[f],e=l.charAt(0),l.length>=2&&e==="["?a[f]=b(l):e!=="\\"&&(a[f]=l.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var x=0,m=!1,j=!1,k=0,c=a.length;k<c;++k){var i=a[k];if(i.ignoreCase)j=!0;else if(/[a-z]/i.test(i.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){m=!0;j=!1;break}}for(var r={b:8,t:9,n:10,v:11,
f:12,r:13},n=[],k=0,c=a.length;k<c;++k){i=a[k];if(i.global||i.multiline)throw Error(""+i);n.push("(?:"+s(i)+")")}return RegExp(n.join("|"),j?"gi":"g")}function S(a,d){function g(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)g(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)s[j]="\n",m[j<<1]=x++,m[j++<<1|1]=a}}else if(c==3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\r\n?/g,"\n"):c.replace(/[\t\n\r ]+/g," "),s[j]=c,m[j<<1]=x,x+=c.length,m[j++<<1|1]=
a)}var b=/(?:^|\s)nocode(?:\s|$)/,s=[],x=0,m=[],j=0;g(a);return{a:s.join("").replace(/\n$/,""),d:m}}function H(a,d,g,b){d&&(a={a:d,e:a},g(a),b.push.apply(b,a.g))}function T(a){for(var d=void 0,g=a.firstChild;g;g=g.nextSibling)var b=g.nodeType,d=b===1?d?a:g:b===3?U.test(g.nodeValue)?a:d:d;return d===a?void 0:d}function D(a,d){function g(a){for(var j=a.e,k=[j,"pln"],c=0,i=a.a.match(s)||[],r={},n=0,e=i.length;n<e;++n){var z=i[n],w=r[z],t=void 0,f;if(typeof w==="string")f=!1;else{var h=b[z.charAt(0)];
if(h)t=z.match(h[1]),w=h[0];else{for(f=0;f<x;++f)if(h=d[f],t=z.match(h[1])){w=h[0];break}t||(w="pln")}if((f=w.length>=5&&"lang-"===w.substring(0,5))&&!(t&&typeof t[1]==="string"))f=!1,w="src";f||(r[z]=w)}h=c;c+=z.length;if(f){f=t[1];var l=z.indexOf(f),B=l+f.length;t[2]&&(B=z.length-t[2].length,l=B-f.length);w=w.substring(5);H(j+h,z.substring(0,l),g,k);H(j+h+l,f,I(w,f),k);H(j+h+B,z.substring(B),g,k)}else k.push(j+h,w)}a.g=k}var b={},s;(function(){for(var g=a.concat(d),j=[],k={},c=0,i=g.length;c<i;++c){var r=
g[c],n=r[3];if(n)for(var e=n.length;--e>=0;)b[n.charAt(e)]=r;r=r[1];n=""+r;k.hasOwnProperty(n)||(j.push(r),k[n]=q)}j.push(/[\S\s]/);s=R(j)})();var x=d.length;return g}function v(a){var d=[],g=[];a.tripleQuotedStrings?d.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?d.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
q,"'\"`"]):d.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&g.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),g.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,q])):d.push(["com",
/^#[^\n\r]*/,q,"#"]));a.cStyleComments&&(g.push(["com",/^\/\/[^\n\r]*/,q]),g.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));if(b=a.regexLiterals){var s=(b=b>1?"":"\n\r")?".":"[\\S\\s]";g.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+("/(?=[^/*"+b+"])(?:[^/\\x5B\\x5C"+b+"]|\\x5C"+s+"|\\x5B(?:[^\\x5C\\x5D"+b+"]|\\x5C"+
s+")*(?:\\x5D|$))+/")+")")])}(b=a.types)&&g.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&g.push(["kwd",RegExp("^(?:"+b.replace(/[\s,]+/g,"|")+")\\b"),q]);d.push(["pln",/^\s+/,q," \r\n\t\u00a0"]);b="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(b+="(?!s*/)");g.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,
q],["pun",RegExp(b),q]);return D(d,g)}function J(a,d,g){function b(a){var c=a.nodeType;if(c==1&&!x.test(a.className))if("br"===a.nodeName)s(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&g){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(j.createTextNode(d),a.nextSibling),s(a),c||a.parentNode.removeChild(a)}}function s(a){function b(a,c){var d=
c?a.cloneNode(!1):a,e=a.parentNode;if(e){var e=b(e,1),g=a.nextSibling;e.appendChild(d);for(var i=g;i;i=g)g=i.nextSibling,e.appendChild(i)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var x=/(?:^|\s)nocode(?:\s|$)/,m=/\r\n?|\n/,j=a.ownerDocument,k=j.createElement("li");a.firstChild;)k.appendChild(a.firstChild);for(var c=[k],i=0;i<c.length;++i)b(c[i]);d===(d|0)&&c[0].setAttribute("value",d);var r=j.createElement("ol");
r.className="linenums";for(var d=Math.max(0,d-1|0)||0,i=0,n=c.length;i<n;++i)k=c[i],k.className="L"+(i+d)%10,k.firstChild||k.appendChild(j.createTextNode("\u00a0")),r.appendChild(k);a.appendChild(r)}function p(a,d){for(var g=d.length;--g>=0;){var b=d[g];F.hasOwnProperty(b)?E.console&&console.warn("cannot override language handler %s",b):F[b]=a}}function I(a,d){if(!a||!F.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";return F[a]}function K(a){var d=a.h;try{var g=S(a.c,a.i),b=g.a;
a.a=b;a.d=g.d;a.e=0;I(d,b)(a);var s=/\bMSIE\s(\d+)/.exec(navigator.userAgent),s=s&&+s[1]<=8,d=/\n/g,x=a.a,m=x.length,g=0,j=a.d,k=j.length,b=0,c=a.g,i=c.length,r=0;c[i]=m;var n,e;for(e=n=0;e<i;)c[e]!==c[e+2]?(c[n++]=c[e++],c[n++]=c[e++]):e+=2;i=n;for(e=n=0;e<i;){for(var p=c[e],w=c[e+1],t=e+2;t+2<=i&&c[t+1]===w;)t+=2;c[n++]=p;c[n++]=w;e=t}c.length=n;var f=a.c,h;if(f)h=f.style.display,f.style.display="none";try{for(;b<k;){var l=j[b+2]||m,B=c[r+2]||m,t=Math.min(l,B),A=j[b+1],G;if(A.nodeType!==1&&(G=x.substring(g,
t))){s&&(G=G.replace(d,"\r"));A.nodeValue=G;var L=A.ownerDocument,o=L.createElement("span");o.className=c[r+1];var v=A.parentNode;v.replaceChild(o,A);o.appendChild(A);g<l&&(j[b+1]=A=L.createTextNode(x.substring(t,l)),v.insertBefore(A,o.nextSibling))}g=t;g>=l&&(b+=2);g>=B&&(r+=2)}}finally{if(f)f.style.display=h}}catch(u){E.console&&console.log(u&&u.stack||u)}}var E=window,y=["break,continue,do,else,for,if,return,while"],C=[[y,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],M=[C,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],V=[C,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],
N=[C,"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,internal,into,is,let,lock,null,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],C=[C,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],O=[y,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
P=[y,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],W=[y,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],y=[y,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],Q=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,
U=/\S/,X=v({keywords:[M,N,C,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",O,P,y],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),F={};p(X,["default-code"]);p(D([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",
/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i] ]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);p(D([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"] ],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],
["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",/^style\s*=\s*([^\s"'>]+)/i] ]),["in.tag"]);p(D([],[["atv",/^[\S\s]+/] ]),["uq.val"]);p(v({keywords:M,hashComments:!0,cStyleComments:!0,types:Q}),["c","cc","cpp","cxx","cyc","m"]);p(v({keywords:"null,true,false"}),["json"]);p(v({keywords:N,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:Q}),
["cs"]);p(v({keywords:V,cStyleComments:!0}),["java"]);p(v({keywords:y,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);p(v({keywords:O,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);p(v({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);p(v({keywords:P,
hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);p(v({keywords:C,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);p(v({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);p(v({keywords:W,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);
p(D([],[["str",/^[\S\s]+/] ]),["regex"]);var Y=E.PR={createSimpleLexer:D,registerLangHandler:p,sourceDecorator:v,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:E.prettyPrintOne=function(a,d,g){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;g&&J(b,g,!0);K({h:d,j:g,c:b,i:1});
return b.innerHTML},prettyPrint:E.prettyPrint=function(a,d){function g(){for(var b=E.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;i<p.length&&c.now()<b;i++){for(var d=p[i],j=h,k=d;k=k.previousSibling;){var m=k.nodeType,o=(m===7||m===8)&&k.nodeValue;if(o?!/^\??prettify\b/.test(o):m!==3||/\S/.test(k.nodeValue))break;if(o){j={};o.replace(/\b(\w+)=([\w%+\-.:]+)/g,function(a,b,c){j[b]=c});break}}k=d.className;if((j!==h||e.test(k))&&!v.test(k)){m=!1;for(o=d.parentNode;o;o=o.parentNode)if(f.test(o.tagName)&&
o.className&&e.test(o.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=j.lang;if(!m){var m=k.match(n),y;if(!m&&(y=T(d))&&t.test(y.tagName))m=y.className.match(n);m&&(m=m[1])}if(w.test(d.tagName))o=1;else var o=d.currentStyle,u=s.defaultView,o=(o=o?o.whiteSpace:u&&u.getComputedStyle?u.getComputedStyle(d,q).getPropertyValue("white-space"):0)&&"pre"===o.substring(0,3);u=j.linenums;if(!(u=u==="true"||+u))u=(u=k.match(/\blinenums\b(?::(\d+))?/))?u[1]&&u[1].length?+u[1]:!0:!1;u&&J(d,u,o);r=
{h:m,c:d,j:u,i:o};K(r)}}}i<p.length?setTimeout(g,250):"function"===typeof a&&a()}for(var b=d||document.body,s=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],p=[],m=0;m<b.length;++m)for(var j=0,k=b[m].length;j<k;++j)p.push(b[m][j]);var b=q,c=Date;c.now||(c={now:function(){return+new Date}});var i=0,r,n=/\blang(?:uage)?-([\w.]+)(?!\S)/,e=/\bprettyprint\b/,v=/\bprettyprinted\b/,w=/pre|xmp/i,t=/^code$/i,f=/^(?:pre|code|xmp)$/i,
h={};g()}};typeof define==="function"&&define.amd&&define("google-code-prettify",[],function(){return Y})})();}()
</script>
<style>
.pln{color:#1b181b}.str{color:#918b3b}.kwd{color:#7b59c0}.com{color:#9e8f9e}.typ{color:#516aec}.lit{color:#a65926}.clo,.opn,.pun{color:#1b181b}.tag{color:#ca402b}.atn{color:#a65926}.atv{color:#159393}.dec{color:#a65926}.var{color:#ca402b}.fun{color:#516aec}pre.prettyprint{background:#f7f3f7;color:#ab9bab;font-family:Menlo,Consolas,"Bitstream Vera Sans Mono","DejaVu Sans Mono",Monaco,monospace;font-size:12px;line-height:1.5;border:1px solid #d8cad8;padding:10px}ol.linenums{margin-top:0;margin-bottom:0}
body {
    min-width: 200px;
    max-width: 850px;
    margin: 0 auto;
    padding: 30px;
}
a:link,a:visited{color:#00f}.codeblock_name,code,pre.prettyprint{font-family:Monaco,"Lucida Console",monospace}body{font-size:14pt}.codeblock_name,.math,.seealso,code{font-size:10pt}.codeblock{page-break-inside:avoid;padding-bottom:15px}.math{text-indent:0}pre.prettyprint{font-size:10pt;padding:10px;border-radius:10px;border:none;white-space:pre-wrap}.codeblock_name{margin-top:1.25em;display:block}a:link{text-decoration:none}a:link:not(.lit):hover{color:#00f;text-decoration:underline}a:link:active{color:red}h4{padding-right:1.25em}h4.noheading{margin-bottom:0}h1{text-align:center}code{padding:2px}pre{-moz-tab-size:4;-o-tab-size:4;tab-size:4}p:not(.notp){margin:0;text-indent:2em}.two-col{list-style-type:none}.two-col li:before{content:'-';padding:5px;margin-right:5px;color:orange;background-color:#fff;display:inline-block}@media print{body{font-size:10pt}pre.prettyprint{font-size:8pt}.seealso{font-size:9pt}.codeblock_name,.math,code{font-size:8pt}.math{text-indent:0}}
</style>
</head>
<body onload="prettyPrint()">
<section>
<h1>Word Count Program</h1>
<a name="1:1"><div class="section"><h4>1. An example of Literate programming</h4></a>
<p>This example is a close adaptation of a tutorial example for Knuth and Levy's <code>CWEB</code> programming system,
translated from <code>CWEB</code> to the <code>Literate</code> programming system. 
That example in turn is based on a program by Klaus Guntermann and Joachim Schrod 
[<em>TUGboat</em> <strong>7</strong> (1986), 134–137] for a version of the "word count" program from <code>UNIX</code>.
</p>
<p>This example demonstrates literate programming in C, although the 
<code>Literate</code> programming system can be used in conjunction with any programming language. 
The level of detail in this document is intentionally high, 
for didactic purposes; many of the things spelled out here don’t need to be explained in other programs.
</p>
<p>The purpose of <code>wc</code> is to count lines, words, and/or characters in a list of files. 
The number of lines in a file is the number of newline characters it contains. 
The number of characters is the file length in bytes. A "word" is a maximal 
sequence of consecutive characters other than newline, space, or tab, containing at 
least one visible ASCII code. (We assume that the standard ASCII code is in use.)
</p>
<p>This version of <code>wc</code> has a nonstandard "silent" option (<code>-s</code>), which suppresses printing 
except for the grand totals over all files.
</p>

</div>
<a name="1:2"><div class="section"><h4 class="noheading">2. </h4></a>
<p>Most <code>Literate</code> programs share a common structure. It’s probably a good idea to state 
the overall structure explicitly at the outset, even though the various parts could all be 
introduced in a piecemeal fashion.
</p>
<p>Here, then, is an overview of the file <code>wc.c</code> that is defined by this <code>Literate</code> program <code>wc.lit</code>:
</p>

<div class="codeblock">
<span class="codeblock_name">{<strong>wc.c</strong> <a href="wc.html#1:2">2</a>}</span>
<pre class="prettyprint lang-c">
<span class="nocode pln">{Header files to include, <a href="wc.html#1:3">3</a>}</span>
<span class="nocode pln">{Preprocessor definitions, <a href="wc.html#1:4">4</a>}</span>
<span class="nocode pln">{Global variables, <a href="wc.html#1:4">4</a>}</span>
<span class="nocode pln">{Functions, <a href="wc.html#1:20">20</a>}</span>
<span class="nocode pln">{The main program, <a href="wc.html#1:5">5</a>}</span>
</pre>



</div>
</div>
<a name="1:3"><div class="section"><h4 class="noheading">3. </h4></a>
<p>We must include the standard I/O definitions, since we want to send formatted output to <em>stdout</em> and <em>stderr</em>.
</p>

<div class="codeblock">
<span class="codeblock_name">{Header files to include <a href="wc.html#1:3">3</a>}</span>
<pre class="prettyprint lang-c">
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
</pre>


<p class="seealso">Used in section <a href="wc.html#1:2">2</a></p>
</div>
</div>
<a name="1:4"><div class="section"><h4 class="noheading">4. </h4></a>
<p>The <code>status</code> variable will tell the operating system if the run was successful or not, 
and <code>prog_name</code> is used in case there’s an error message to be printed.
</p>

<div class="codeblock">
<span class="codeblock_name">{Preprocessor definitions <a href="wc.html#1:4">4</a>}</span>
<pre class="prettyprint lang-c">
#define OK 0    /* status code for successful run */
#define usage_error 1    /* status code for improper syntax */
#define cannot_open_file 2    /* status code for file access error */ 
</pre>
<p class="seealso">Added to in section <a href="wc.html#1:10">10</a></p>

<p class="seealso">Used in section <a href="wc.html#1:2">2</a></p>
</div>

<div class="codeblock">
<span class="codeblock_name">{Global variables <a href="wc.html#1:4">4</a>}</span>
<pre class="prettyprint lang-c">
int status = OK;    /* exit status of command, initially OK */
char *prog_name;    /* who we are */
</pre>
<p class="seealso">Added to in section <a href="wc.html#1:14">14</a></p>

<p class="seealso">Used in section <a href="wc.html#1:2">2</a></p>
</div>
</div>
<a name="1:5"><div class="section"><h4 class="noheading">5. </h4></a>
<p>Now we come to the general layout of the <code>main()</code> function.
</p>

<div class="codeblock">
<span class="codeblock_name">{The main program <a href="wc.html#1:5">5</a>}</span>
<pre class="prettyprint lang-c">
int main(int argc, char **argv)
{
<span class="nocode pln">    {Variables local to main, <a href="wc.html#1:6">6</a>}</span>
    prog_name = argv[0];
<span class="nocode pln">    {Set up option selection, <a href="wc.html#1:7">7</a>}</span>
<span class="nocode pln">    {Process all the files, <a href="wc.html#1:8">8</a>}</span>
<span class="nocode pln">    {Print the grand totals if there were multiple files, <a href="wc.html#1:19">19</a>}</span>
    return status;
}
</pre>


<p class="seealso">Used in section <a href="wc.html#1:2">2</a></p>
</div>
</div>
<a name="1:6"><div class="section"><h4 class="noheading">6. </h4></a>
<p>If the first argument begins with a '<code>-</code>', the user is choosing the desired counts and 
specifying the order in which they should be displayed. Each selection is given by the 
initial character (lines, words, or characters). For example, '<code>-cl</code>' would cause just 
the number of characters and the number of lines to be printed, in that order. The 
default, if no special argument is given, is '<code>-lwc</code>'.
</p>
<p>We do not process this string now; we simply remember where it is. It will be used 
to control the formatting at output time.
</p>
<p>If the '<code>-</code>' is immediately followed by '<code>s</code>', only summary totals are printed.
</p>

<div class="codeblock">
<span class="codeblock_name">{Variables local to main <a href="wc.html#1:6">6</a>}</span>
<pre class="prettyprint lang-c">
int file_count;    /* how many files there are */
char *which;    /* which counts to print */
int silent = 0;    /* nonzero if the silent option was selected */
</pre>
<p class="seealso">Added to in sections <a href="wc.html#1:9">9</a> and <a href="wc.html#1:12">12</a></p>

<p class="seealso">Used in section <a href="wc.html#1:5">5</a></p>
</div>
</div>
<a name="1:7"><div class="section"><h4 class="noheading">7. </h4></a>

<div class="codeblock">
<span class="codeblock_name">{Set up option selection <a href="wc.html#1:7">7</a>}</span>
<pre class="prettyprint lang-c">
which = "lwc";    /* if no option is given, print all three values */
if (argc &gt;1 &amp;&amp; *argv[1] == '-') {
    argv[1]++;
    if (*argv [1] == 's') silent = 1, argv [1]++;
    if (*argv [1]) which = argv [1];
    argc--;
    argv++;
}
file_count = argc - 1;
</pre>


<p class="seealso">Used in section <a href="wc.html#1:5">5</a></p>
</div>
</div>
<a name="1:8"><div class="section"><h4 class="noheading">8. </h4></a>
<p>Now we scan the remaining arguments and try to open a file, if possible. The file 
is processed and its statistics are given. We use a <code>do ... while</code> loop because 
we should read from the standard input if no file name is given.
</p>

<div class="codeblock">
<span class="codeblock_name">{Process all the files <a href="wc.html#1:8">8</a>}</span>
<pre class="prettyprint lang-c">
argc--;
do {
<span class="nocode pln">    {If a file is given, try to open *(++argv ); continue if unsuccessful, <a href="wc.html#1:10">10</a>}</span>
<span class="nocode pln">    {Initialize pointers and counters, <a href="wc.html#1:13">13</a>}</span>
<span class="nocode pln">    {Scan file, <a href="wc.html#1:15">15</a>}</span>
<span class="nocode pln">    {Write statistics for file, <a href="wc.html#1:17">17</a>}</span>
<span class="nocode pln">    {Close file, <a href="wc.html#1:11">11</a>}</span>
<span class="nocode pln">    {Update grand totals, <a href="wc.html#1:18">18</a>}</span>
} while (--argc &gt; 0);
</pre>


<p class="seealso">Used in section <a href="wc.html#1:5">5</a></p>
</div>
</div>
<a name="1:9"><div class="section"><h4 class="noheading">9. </h4></a>
<p>Here’s the code to open the file. A special trick allows us to handle input from <em>stdin</em> 
when no name is given. Recall that the file descriptor to <em>stdin</em> is <code>0</code>; that’s what we 
use as the default initial value.
</p>

<div class="codeblock">
<span class="codeblock_name">{Variables local to main <a href="wc.html#1:6">6</a>}</span>
<pre class="prettyprint lang-c">
int fd = 0;
</pre>
<p class="seealso">Added to in section <a href="wc.html#1:12">12</a></p>

<p class="seealso">Used in section <a href="wc.html#1:5">5</a></p>
</div>
</div>
<a name="1:10"><div class="section"><h4 class="noheading">10. </h4></a>

<div class="codeblock">
<span class="codeblock_name">{Preprocessor definitions <a href="wc.html#1:4">4</a>}</span>
<pre class="prettyprint lang-c">
#define READ_ONLY 0
</pre>


<p class="seealso">Used in section <a href="wc.html#1:2">2</a></p>
</div>

<div class="codeblock">
<span class="codeblock_name">{If a file is given, try to open *(++argv ); continue if unsuccessful <a href="wc.html#1:10">10</a>}</span>
<pre class="prettyprint lang-c">
if (file_count &gt; 0 &amp;&amp; (fd = open(*(++argv), READ_ONLY)) &lt; 0) {
    fprintf(stderr, "%s: cannot open file %s\n", prog_name, *argv);
    status |= 2;
    file_count--;
    continue;
}
</pre>


<p class="seealso">Used in section <a href="wc.html#1:8">8</a></p>
</div>
</div>
<a name="1:11"><div class="section"><h4 class="noheading">11. </h4></a>

<div class="codeblock">
<span class="codeblock_name">{Close file <a href="wc.html#1:11">11</a>}</span>
<pre class="prettyprint lang-c">
close(fd);
</pre>


<p class="seealso">Used in section <a href="wc.html#1:8">8</a></p>
</div>
</div>
<a name="1:12"><div class="section"><h4 class="noheading">12. </h4></a>
<p>We will do some homemade buffering in order to speed things up: Characters will be 
read into the buffer array before we process them. To do this we set up appropriate 
pointers and counters.
</p>

<div class="codeblock">
<span class="codeblock_name">{Variables local to main <a href="wc.html#1:6">6</a>}</span>
<pre class="prettyprint lang-c">
char buffer[BUFSIZ];    /* we read the input into this array */
register char *ptr;    /* the first unprocessed character in buffer */
register char *buf_end;    /* the first unused position in buffer */
register int c;    /* current character or number of characters just read */
int in_word;    /* are we within a word? */
long word_count, line_count, char_count;   
    /* number of words, lines, and characters found in the file so far */
</pre>
<p class="seealso">Added to in section <a href="wc.html#1:9">9</a></p>

<p class="seealso">Used in section <a href="wc.html#1:5">5</a></p>
</div>
</div>
<a name="1:13"><div class="section"><h4 class="noheading">13. </h4></a>

<div class="codeblock">
<span class="codeblock_name">{Initialize pointers and counters <a href="wc.html#1:13">13</a>}</span>
<pre class="prettyprint lang-c">
ptr = buf_end = buffer;
line_count = word_count = char_count = 0;
in_word = 0;
</pre>


<p class="seealso">Used in section <a href="wc.html#1:8">8</a></p>
</div>
</div>
<a name="1:14"><div class="section"><h4 class="noheading">14. </h4></a>
<p>The grand totals must be initialized to zero at the beginning of the program. 
If we made these variables local to main, we would have to do this initialization explicitly; 
however, C’s globals are automatically zeroed. (Or rather, "statically zeroed.") (Get it?)
</p>

<div class="codeblock">
<span class="codeblock_name">{Global variables <a href="wc.html#1:4">4</a>}</span>
<pre class="prettyprint lang-c">
long tot_word_count, tot_line_count, tot_char_count; 
    /* total number of words, lines and chars */
</pre>


<p class="seealso">Used in section <a href="wc.html#1:2">2</a></p>
</div>
</div>
<a name="1:15"><div class="section"><h4 class="noheading">15. </h4></a>
<p>The present section, which does the counting that is <code>wc</code>'s <em>raison d'être</em>, was actually 
one of the simplest to write. We look at each character and change state if it begins or ends a word.
</p>

<div class="codeblock">
<span class="codeblock_name">{Scan file <a href="wc.html#1:15">15</a>}</span>
<pre class="prettyprint lang-c">
while (1) {
<span class="nocode pln">    {Fill buffer if it is empty; break at end of file, <a href="wc.html#1:16">16</a>}</span>
    c = *ptr++;
    if (c &gt; ' ' &amp;&amp; c &lt; 177) {    /* visible ASCII codes */
        if (!in_word) {
            word_count++;
            in_word = 1;
        }
        continue;
    }
    if (c == '\n') line_count++;
    else if (c != ' ' &amp;&amp; c != '\t') continue;
    in_word = 0;    /* c is newline, space, or tab */
}
</pre>


<p class="seealso">Used in section <a href="wc.html#1:8">8</a></p>
</div>
</div>
<a name="1:16"><div class="section"><h4 class="noheading">16. </h4></a>
<p>Buffered I/O allows us to count the number of characters almost for free.
</p>

<div class="codeblock">
<span class="codeblock_name">{Fill buffer if it is empty; break at end of file <a href="wc.html#1:16">16</a>}</span>
<pre class="prettyprint lang-c">
if (ptr &gt;= buf_end) {
    ptr = buffer;
    c = read(fd, ptr, BUFSIZ);
    if (c &lt;= 0) break;
    char_count += c;
    buf_end = buffer + c;
}
</pre>


<p class="seealso">Used in section <a href="wc.html#1:15">15</a></p>
</div>
</div>
<a name="1:17"><div class="section"><h4 class="noheading">17. </h4></a>
<p>It’s convenient to output the statistics by defining a new function <code>wc_print()</code>; 
then the same function can be used for the totals. Additionally we must decide here 
if we know the name of the file we have processed or if it was just <em>stdin</em>.
</p>

<div class="codeblock">
<span class="codeblock_name">{Write statistics for file <a href="wc.html#1:17">17</a>}</span>
<pre class="prettyprint lang-c">
if (!silent) {
    wc_print(which, char_count, word_count, line_count);
    if (file_count) printf(" %s\n", *argv);    /* not stdin */
    else printf("\n");    /* stdin */
}
</pre>


<p class="seealso">Used in section <a href="wc.html#1:8">8</a></p>
</div>
</div>
<a name="1:18"><div class="section"><h4 class="noheading">18. </h4></a>

<div class="codeblock">
<span class="codeblock_name">{Update grand totals <a href="wc.html#1:18">18</a>}</span>
<pre class="prettyprint lang-c">
tot_line_count += line_count;
tot_word_count += word_count;
tot_char_count += char_count;
</pre>


<p class="seealso">Used in section <a href="wc.html#1:8">8</a></p>
</div>
</div>
<a name="1:19"><div class="section"><h4 class="noheading">19. </h4></a>
<p>We might as well improve a bit on <code>UNIX</code>’s <code>wc</code> by displaying the number of files too.
</p>

<div class="codeblock">
<span class="codeblock_name">{Print the grand totals if there were multiple files <a href="wc.html#1:19">19</a>}</span>
<pre class="prettyprint lang-c">
if (file_count &gt; 1 || silent) {
    wc_print(which, tot_char_count, tot_word_count, tot_line_count);
    if (!file_count) printf("\n");
    else printf(" total in %d file%s\n", file_count, file_count &gt; 1 ? "s" : "");
}
</pre>


<p class="seealso">Used in section <a href="wc.html#1:5">5</a></p>
</div>
</div>
<a name="1:20"><div class="section"><h4 class="noheading">20. </h4></a>
<p>Here now is the function that prints the values according to the specified options. 
The calling routine is supposed to supply a newline. If an invalid option character 
is found we inform the user about proper usage of the command. Counts are printed 
in 8-digit fields so that they will line up in columns.
</p>

<div class="codeblock">
<span class="codeblock_name">{Functions <a href="wc.html#1:20">20</a>}</span>
<pre class="prettyprint lang-c">
void wc_print(char *which, long char_count, long word_count, long line_count)
{
    while (*which)
        switch (*which++) {
        case 'l': printf("%8ld", line_count);
            break;
        case 'w': printf("%8ld", word_count);
            break;
        case 'c': printf("%8ld", char_count);
            break;
        default:
            if ((status &amp; 1) == 0) {
                fprintf(stderr, "\nUsage: %s [-lwc] [filename ...]\n", prog_name);
                status |= 1;
            }
        }
}
</pre>


<p class="seealso">Used in section <a href="wc.html#1:2">2</a></p>
</div>

</div>
</body>
