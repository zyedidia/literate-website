<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Parser</title>
<script>
!function(){var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
(function(){function R(a){function d(e){var b=e.charCodeAt(0);if(b!==92)return b;var a=e.charAt(1);return(b=r[a])?b:"0"<=a&&a<="7"?parseInt(e.substring(1),8):a==="u"||a==="x"?parseInt(e.substring(2),16):e.charCodeAt(1)}function g(e){if(e<32)return(e<16?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return e==="\\"||e==="-"||e==="]"||e==="^"?"\\"+e:e}function b(e){var b=e.substring(1,e.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),e=[],a=
b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,f=b.length;a<f;++a){var h=b[a];if(/\\[bdsw]/i.test(h))c.push(h);else{var h=d(h),l;a+2<f&&"-"===b[a+1]?(l=d(b[a+2]),a+=2):l=h;e.push([h,l]);l<65||h>122||(l<65||h>90||e.push([Math.max(65,h)|32,Math.min(l,90)|32]),l<97||h>122||e.push([Math.max(97,h)&-33,Math.min(l,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});b=[];f=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=f[1]+1?f[1]=Math.max(f[1],h[1]):b.push(f=h);for(a=0;a<b.length;++a)h=b[a],c.push(g(h[0])),
h[1]>h[0]&&(h[1]+1>h[0]&&c.push("-"),c.push(g(h[1])));c.push("]");return c.join("")}function s(e){for(var a=e.source.match(/\[(?:[^\\\] ]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),c=a.length,d=[],f=0,h=0;f<c;++f){var l=a[f];l==="("?++h:"\\"===l.charAt(0)&&(l=+l.substring(1))&&(l<=h?d[l]=-1:a[f]=g(l))}for(f=1;f<d.length;++f)-1===d[f]&&(d[f]=++x);for(h=f=0;f<c;++f)l=a[f],l==="("?(++h,d[h]||(a[f]="(?:")):"\\"===l.charAt(0)&&(l=+l.substring(1))&&l<=h&&
(a[f]="\\"+d[l]);for(f=0;f<c;++f)"^"===a[f]&&"^"!==a[f+1]&&(a[f]="");if(e.ignoreCase&&m)for(f=0;f<c;++f)l=a[f],e=l.charAt(0),l.length>=2&&e==="["?a[f]=b(l):e!=="\\"&&(a[f]=l.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var x=0,m=!1,j=!1,k=0,c=a.length;k<c;++k){var i=a[k];if(i.ignoreCase)j=!0;else if(/[a-z]/i.test(i.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){m=!0;j=!1;break}}for(var r={b:8,t:9,n:10,v:11,
f:12,r:13},n=[],k=0,c=a.length;k<c;++k){i=a[k];if(i.global||i.multiline)throw Error(""+i);n.push("(?:"+s(i)+")")}return RegExp(n.join("|"),j?"gi":"g")}function S(a,d){function g(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)g(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)s[j]="\n",m[j<<1]=x++,m[j++<<1|1]=a}}else if(c==3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\r\n?/g,"\n"):c.replace(/[\t\n\r ]+/g," "),s[j]=c,m[j<<1]=x,x+=c.length,m[j++<<1|1]=
a)}var b=/(?:^|\s)nocode(?:\s|$)/,s=[],x=0,m=[],j=0;g(a);return{a:s.join("").replace(/\n$/,""),d:m}}function H(a,d,g,b){d&&(a={a:d,e:a},g(a),b.push.apply(b,a.g))}function T(a){for(var d=void 0,g=a.firstChild;g;g=g.nextSibling)var b=g.nodeType,d=b===1?d?a:g:b===3?U.test(g.nodeValue)?a:d:d;return d===a?void 0:d}function D(a,d){function g(a){for(var j=a.e,k=[j,"pln"],c=0,i=a.a.match(s)||[],r={},n=0,e=i.length;n<e;++n){var z=i[n],w=r[z],t=void 0,f;if(typeof w==="string")f=!1;else{var h=b[z.charAt(0)];
if(h)t=z.match(h[1]),w=h[0];else{for(f=0;f<x;++f)if(h=d[f],t=z.match(h[1])){w=h[0];break}t||(w="pln")}if((f=w.length>=5&&"lang-"===w.substring(0,5))&&!(t&&typeof t[1]==="string"))f=!1,w="src";f||(r[z]=w)}h=c;c+=z.length;if(f){f=t[1];var l=z.indexOf(f),B=l+f.length;t[2]&&(B=z.length-t[2].length,l=B-f.length);w=w.substring(5);H(j+h,z.substring(0,l),g,k);H(j+h+l,f,I(w,f),k);H(j+h+B,z.substring(B),g,k)}else k.push(j+h,w)}a.g=k}var b={},s;(function(){for(var g=a.concat(d),j=[],k={},c=0,i=g.length;c<i;++c){var r=
g[c],n=r[3];if(n)for(var e=n.length;--e>=0;)b[n.charAt(e)]=r;r=r[1];n=""+r;k.hasOwnProperty(n)||(j.push(r),k[n]=q)}j.push(/[\S\s]/);s=R(j)})();var x=d.length;return g}function v(a){var d=[],g=[];a.tripleQuotedStrings?d.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?d.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
q,"'\"`"]):d.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&g.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),g.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,q])):d.push(["com",
/^#[^\n\r]*/,q,"#"]));a.cStyleComments&&(g.push(["com",/^\/\/[^\n\r]*/,q]),g.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));if(b=a.regexLiterals){var s=(b=b>1?"":"\n\r")?".":"[\\S\\s]";g.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+("/(?=[^/*"+b+"])(?:[^/\\x5B\\x5C"+b+"]|\\x5C"+s+"|\\x5B(?:[^\\x5C\\x5D"+b+"]|\\x5C"+
s+")*(?:\\x5D|$))+/")+")")])}(b=a.types)&&g.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&g.push(["kwd",RegExp("^(?:"+b.replace(/[\s,]+/g,"|")+")\\b"),q]);d.push(["pln",/^\s+/,q," \r\n\t\u00a0"]);b="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(b+="(?!s*/)");g.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,
q],["pun",RegExp(b),q]);return D(d,g)}function J(a,d,g){function b(a){var c=a.nodeType;if(c==1&&!x.test(a.className))if("br"===a.nodeName)s(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&g){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(j.createTextNode(d),a.nextSibling),s(a),c||a.parentNode.removeChild(a)}}function s(a){function b(a,c){var d=
c?a.cloneNode(!1):a,e=a.parentNode;if(e){var e=b(e,1),g=a.nextSibling;e.appendChild(d);for(var i=g;i;i=g)g=i.nextSibling,e.appendChild(i)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var x=/(?:^|\s)nocode(?:\s|$)/,m=/\r\n?|\n/,j=a.ownerDocument,k=j.createElement("li");a.firstChild;)k.appendChild(a.firstChild);for(var c=[k],i=0;i<c.length;++i)b(c[i]);d===(d|0)&&c[0].setAttribute("value",d);var r=j.createElement("ol");
r.className="linenums";for(var d=Math.max(0,d-1|0)||0,i=0,n=c.length;i<n;++i)k=c[i],k.className="L"+(i+d)%10,k.firstChild||k.appendChild(j.createTextNode("\u00a0")),r.appendChild(k);a.appendChild(r)}function p(a,d){for(var g=d.length;--g>=0;){var b=d[g];F.hasOwnProperty(b)?E.console&&console.warn("cannot override language handler %s",b):F[b]=a}}function I(a,d){if(!a||!F.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";return F[a]}function K(a){var d=a.h;try{var g=S(a.c,a.i),b=g.a;
a.a=b;a.d=g.d;a.e=0;I(d,b)(a);var s=/\bMSIE\s(\d+)/.exec(navigator.userAgent),s=s&&+s[1]<=8,d=/\n/g,x=a.a,m=x.length,g=0,j=a.d,k=j.length,b=0,c=a.g,i=c.length,r=0;c[i]=m;var n,e;for(e=n=0;e<i;)c[e]!==c[e+2]?(c[n++]=c[e++],c[n++]=c[e++]):e+=2;i=n;for(e=n=0;e<i;){for(var p=c[e],w=c[e+1],t=e+2;t+2<=i&&c[t+1]===w;)t+=2;c[n++]=p;c[n++]=w;e=t}c.length=n;var f=a.c,h;if(f)h=f.style.display,f.style.display="none";try{for(;b<k;){var l=j[b+2]||m,B=c[r+2]||m,t=Math.min(l,B),A=j[b+1],G;if(A.nodeType!==1&&(G=x.substring(g,
t))){s&&(G=G.replace(d,"\r"));A.nodeValue=G;var L=A.ownerDocument,o=L.createElement("span");o.className=c[r+1];var v=A.parentNode;v.replaceChild(o,A);o.appendChild(A);g<l&&(j[b+1]=A=L.createTextNode(x.substring(t,l)),v.insertBefore(A,o.nextSibling))}g=t;g>=l&&(b+=2);g>=B&&(r+=2)}}finally{if(f)f.style.display=h}}catch(u){E.console&&console.log(u&&u.stack||u)}}var E=window,y=["break,continue,do,else,for,if,return,while"],C=[[y,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],M=[C,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],V=[C,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],
N=[C,"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,internal,into,is,let,lock,null,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],C=[C,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],O=[y,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
P=[y,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],W=[y,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],y=[y,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],Q=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,
U=/\S/,X=v({keywords:[M,N,C,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",O,P,y],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),F={};p(X,["default-code"]);p(D([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",
/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i] ]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);p(D([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"] ],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],
["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",/^style\s*=\s*([^\s"'>]+)/i] ]),["in.tag"]);p(D([],[["atv",/^[\S\s]+/] ]),["uq.val"]);p(v({keywords:M,hashComments:!0,cStyleComments:!0,types:Q}),["c","cc","cpp","cxx","cyc","m"]);p(v({keywords:"null,true,false"}),["json"]);p(v({keywords:N,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:Q}),
["cs"]);p(v({keywords:V,cStyleComments:!0}),["java"]);p(v({keywords:y,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);p(v({keywords:O,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);p(v({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);p(v({keywords:P,
hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);p(v({keywords:C,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);p(v({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);p(v({keywords:W,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);
p(D([],[["str",/^[\S\s]+/] ]),["regex"]);var Y=E.PR={createSimpleLexer:D,registerLangHandler:p,sourceDecorator:v,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:E.prettyPrintOne=function(a,d,g){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;g&&J(b,g,!0);K({h:d,j:g,c:b,i:1});
return b.innerHTML},prettyPrint:E.prettyPrint=function(a,d){function g(){for(var b=E.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;i<p.length&&c.now()<b;i++){for(var d=p[i],j=h,k=d;k=k.previousSibling;){var m=k.nodeType,o=(m===7||m===8)&&k.nodeValue;if(o?!/^\??prettify\b/.test(o):m!==3||/\S/.test(k.nodeValue))break;if(o){j={};o.replace(/\b(\w+)=([\w%+\-.:]+)/g,function(a,b,c){j[b]=c});break}}k=d.className;if((j!==h||e.test(k))&&!v.test(k)){m=!1;for(o=d.parentNode;o;o=o.parentNode)if(f.test(o.tagName)&&
o.className&&e.test(o.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=j.lang;if(!m){var m=k.match(n),y;if(!m&&(y=T(d))&&t.test(y.tagName))m=y.className.match(n);m&&(m=m[1])}if(w.test(d.tagName))o=1;else var o=d.currentStyle,u=s.defaultView,o=(o=o?o.whiteSpace:u&&u.getComputedStyle?u.getComputedStyle(d,q).getPropertyValue("white-space"):0)&&"pre"===o.substring(0,3);u=j.linenums;if(!(u=u==="true"||+u))u=(u=k.match(/\blinenums\b(?::(\d+))?/))?u[1]&&u[1].length?+u[1]:!0:!1;u&&J(d,u,o);r=
{h:m,c:d,j:u,i:o};K(r)}}}i<p.length?setTimeout(g,250):"function"===typeof a&&a()}for(var b=d||document.body,s=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],p=[],m=0;m<b.length;++m)for(var j=0,k=b[m].length;j<k;++j)p.push(b[m][j]);var b=q,c=Date;c.now||(c={now:function(){return+new Date}});var i=0,r,n=/\blang(?:uage)?-([\w.]+)(?!\S)/,e=/\bprettyprint\b/,v=/\bprettyprinted\b/,w=/pre|xmp/i,t=/^code$/i,f=/^(?:pre|code|xmp)$/i,
h={};g()}};typeof define==="function"&&define.amd&&define("google-code-prettify",[],function(){return Y})})();}()
</script>
<style>
.pln{color:#1b181b}.str{color:#918b3b}.kwd{color:#7b59c0}.com{color:#9e8f9e}.typ{color:#516aec}.lit{color:#a65926}.clo,.opn,.pun{color:#1b181b}.tag{color:#ca402b}.atn{color:#a65926}.atv{color:#159393}.dec{color:#a65926}.var{color:#ca402b}.fun{color:#516aec}pre.prettyprint{background:#f7f3f7;color:#ab9bab;font-family:Menlo,Consolas,"Bitstream Vera Sans Mono","DejaVu Sans Mono",Monaco,monospace;font-size:12px;line-height:1.5;border:1px solid #d8cad8;padding:10px}ol.linenums{margin-top:0;margin-bottom:0}
body {
    min-width: 200px;
    max-width: 850px;
    margin: 0 auto;
    padding: 30px;
}
a:link,a:visited{color:#00f}.codeblock_name,code,pre.prettyprint{font-family:Monaco,"Lucida Console",monospace}body{font-size:14pt}.codeblock_name,.math,.seealso,code{font-size:10pt}.codeblock{page-break-inside:avoid;padding-bottom:15px}.math{text-indent:0}pre.prettyprint{font-size:10pt;padding:10px;border-radius:10px;border:none;white-space:pre-wrap}.codeblock_name{margin-top:1.25em;display:block}a:link{text-decoration:none}a:link:not(.lit):hover{color:#00f;text-decoration:underline}a:link:active{color:red}h4{padding-right:1.25em}h4.noheading{margin-bottom:0}h1{text-align:center}code{padding:2px}pre{-moz-tab-size:4;-o-tab-size:4;tab-size:4}p:not(.notp){margin:0;text-indent:2em}.two-col{list-style-type:none}.two-col li:before{content:'-';padding:5px;margin-right:5px;color:orange;background-color:#fff;display:inline-block}@media print{body{font-size:10pt}pre.prettyprint{font-size:8pt}.seealso{font-size:9pt}.codeblock_name,.math,code{font-size:8pt}.math{text-indent:0}}
</style>
</head>
<body onload="prettyPrint()">
<section>
<h1>Parser</h1>
<a name="1:1"><div class="section"><h4>1. Introduction</h4></a>
<p>This is an implementation of a literate programming system in D.
The goal is to be able to create books that one can read on a website,
with chapters, subchapters, and sections, and additionally to be able
to compile the code from the book into a working program.
</p>
<p>Literate proogramming aims to make the source code of a program
understandable. The program can be structured in any way the
programmer likes, and the code should be explained.
</p>
<p>The source code for a literate program will somewhat resemble
CWEB, but differ in many key ways which simplify the source code
and make it easier to read. Literate will use @ signs for commands
and markdown to style the prose. 
</p>

</div>
<a name="1:2"><div class="section"><h4>2. Directory Structure</h4></a>
<p>A Literate program may be just a single file, but it should also be
possible to make a book out of it, with chapters and possibly multiple
programs in a single book. If the literate command line tool is run on
a single file, it should compile that file, if it is run on a directory,
it should search for the <code>Summary.lit</code> file in the directory and create a
book.
</p>
<p>What should the directory structure of a Literate book look like?
I try to mimic the <a href="https://github.com/GitbookIO/gitbook">Gitbook</a> software
here. There will be a <code>Summary.lit</code> file which links to each of the
different chapters in the book. An example <code>Summary.lit</code> file might look
like this:
</p>
<pre><code>@title Title of the book

[Chapter 1](chapter1/intro.lit)
    [Subchapter 1](chapter1/example1.lit)
    [Subchapter 2](chapter1/example2.lit)
[Chapter 2](section2/intro.lit)
    [Subchapter 1](chapter2/example1.lit)
</code></pre><p>Sub chapters are denoted by tabs, and each chapter is linked to the correct
<code>.lit</code> file using Markdown link syntax.
</p>

</div>
<a name="1:3"><div class="section"><h4>3. The Parser</h4></a>
<p>As a first step, I'll make a parser for single chapters only, and leave having
multiple chapters and books for later.
</p>
<p>The parser will have 2 main parts to it: the which represent the various structures
in a literate program, and the parse function.
</p>

<div class="codeblock">
<span class="codeblock_name">{<strong>parser.d</strong> <a href="dsrc/parser.html#1:3">3</a>}</span>
<pre class="prettyprint lang-d">
<span class="nocode pln">{Imports, <a href="dsrc/parser.html#1:3">3</a>}</span>
<span class="nocode pln">{Classes, <a href="dsrc/parser.html#1:4">4</a>}</span>
<span class="nocode pln">{Parse function, <a href="dsrc/parser.html#1:12">12</a>}</span>
</pre>
</div>
<p>I'll quickly list the imports here.
</p>

<div class="codeblock">
<span class="codeblock_name">{Imports <a href="dsrc/parser.html#1:3">3</a>}</span>
<pre class="prettyprint lang-d">
import std.stdio;
import util;
import std.string: split, startsWith, chomp, replace, strip;
import std.algorithm: canFind;
import std.regex: matchAll, matchFirst, regex;
import std.conv;
import std.path: extension;
import std.file;
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:3">3</a></p>
</div>
</div>
<a name="1:4"><div class="section"><h4 class="noheading">4. </h4></a>
<p>Now we have to define the classes used to represent a literate program. There
are 7 such classes:
</p>

<div class="codeblock">
<span class="codeblock_name">{Classes <a href="dsrc/parser.html#1:4">4</a>}</span>
<pre class="prettyprint lang-d">
<span class="nocode pln">{Line class, <a href="dsrc/parser.html#1:10">10</a>}</span>
<span class="nocode pln">{Command class, <a href="dsrc/parser.html#1:9">9</a>}</span>
<span class="nocode pln">{Block class, <a href="dsrc/parser.html#1:8">8</a>}</span>
<span class="nocode pln">{Section class, <a href="dsrc/parser.html#1:7">7</a>}</span>
<span class="nocode pln">{Chapter class, <a href="dsrc/parser.html#1:6">6</a>}</span>
<span class="nocode pln">{Program class, <a href="dsrc/parser.html#1:5">5</a>}</span>
<span class="nocode pln">{Change class, <a href="dsrc/parser.html#1:11">11</a>}</span>
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:3">3</a></p>
</div>
</div>
<a name="1:5"><div class="section"><h4>5. The Program Class</h4></a>
<p>What is a literate program at the highest level? A program has multiple chapters,
it has a title, and it has various commands associated with it (although some of these
commands may be overwritten by chapters or even sections). It also has the file it
originally came from.
</p>

<div class="codeblock">
<span class="codeblock_name">{Program class <a href="dsrc/parser.html#1:5">5</a>}</span>
<pre class="prettyprint lang-d">
class Program {
    public string title;
    public Command[] commands;
    public Chapter[] chapters;
    public string file;

    this() {
        commands = [];
        chapters = [];
    }
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:6"><div class="section"><h4>6. The Chapter class</h4></a>
<p>A chapter is very similar to a program. It has a title, commands, sections, and also
an original file. In the case of a single file program (which is what we are focusing
on for the moment) the Program's file and the Chapter's file will be the same. A chapter
also has a minor number and a major number;
</p>

<div class="codeblock">
<span class="codeblock_name">{Chapter class <a href="dsrc/parser.html#1:6">6</a>}</span>
<pre class="prettyprint lang-d">
class Chapter {
    public string title;
    public Command[] commands;
    public Section[] sections;
    public string file;

    public int majorNum;
    public int minorNum;

    this() {
        commands = [];
        sections = [];
    }

    string num() {
        if (minorNum != 0) {
            return to!string(majorNum) ~ "." ~ to!string(minorNum);
        } else {
            return to!string(majorNum);
        }
    }
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:7"><div class="section"><h4>7. The Sections class</h4></a>
<p>A section has a title, commands, a number, and a series of blocks, which can either be
blocks of code, or blocks of prose.
</p>

<div class="codeblock">
<span class="codeblock_name">{Section class <a href="dsrc/parser.html#1:7">7</a>}</span>
<pre class="prettyprint lang-d">
class Section {
    public string title;
    public Command[] commands;
    public Block[] blocks;
    public int num;

    this() {
        commands = [];
        blocks = [];
    }
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:8"><div class="section"><h4>8. The Block Class</h4></a>
<p>A block is more interesting. It can either be a block of code, or a block of prose, so
it has a boolean which represents what type it is. It also stores a start line. If it
is a code block, it also has a name. Finally, it stores an array of lines, and has a function
called <code>text()</code> which just returns the string of the text it contains. A block also contains
a <code>codeType</code> and a <code>commentString</code>.
</p>

<div class="codeblock">
<span class="codeblock_name">{Block class <a href="dsrc/parser.html#1:8">8</a>}</span>
<pre class="prettyprint lang-d">
class Block {
    public int startLine;
    public string name;
    public bool isCodeblock;
    public bool isRootBlock;
    public Line[] lines;

    public string codeType;
    public string commentString;

    this() {
        lines = [];
    }

    string text() {
        string text = "";
        foreach (line; lines) {
            text ~= line.text ~ "\n";
        }
        return text;
    }

    Block dup() {
        Block b = new Block();
        b.startLine = startLine;
        b.name = name;
        b.isCodeblock = isCodeblock;
        b.codeType = codeType;
        b.commentString = commentString;

        foreach (Line l; lines) {
            b.lines ~= l.dup();
        }

        return b;
    }
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:9"><div class="section"><h4>9. The Command Class</h4></a>
<p>A command is quite simple. It has a name, and any arguments that are passed.
</p>

<div class="codeblock">
<span class="codeblock_name">{Command class <a href="dsrc/parser.html#1:9">9</a>}</span>
<pre class="prettyprint lang-d">
class Command {
    public string name;
    public string args;
    this() {}
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:10"><div class="section"><h4>10. The Line Class</h4></a>
<p>A line is the lowest level. It stores the line number, the file the line is from, and the
text for the line itself.
</p>

<div class="codeblock">
<span class="codeblock_name">{Line class <a href="dsrc/parser.html#1:10">10</a>}</span>
<pre class="prettyprint lang-d">
class Line {
    public string file;
    public int lineNum;
    public string text;

    this(string text, string file, int lineNum) {
        this.text = text;
        this.file = file;
        this.lineNum = lineNum;
    }

    Line dup() {
        return new Line(text, file, lineNum);
    }
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:4">4</a></p>
</div>
</div>
<a name="1:11"><div class="section"><h4>11. The Change Class</h4></a>
<p>The change class helps when parsing a change statement. It stores the file that is being changed,
what the text to search for is and what the text to replace it with is. These two things are arrays
because you can make multiple changes (search and replaces) to one file. In order to
keep track of the current change, an index is also stored.
</p>

<div class="codeblock">
<span class="codeblock_name">{Change class <a href="dsrc/parser.html#1:11">11</a>}</span>
<pre class="prettyprint lang-d">
class Change {
    public string filename;
    public string[] searchText;
    public string[] replaceText;
    public int index;

    this() {
        searchText = [];
        replaceText = [];
        index = 0;
    }
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:4">4</a></p>
</div>
<p>That's it for the classes. These 7 classes can be used to represent an entire literate program.
Now let's get to the actual parse function to turn a text file into a program.
</p>

</div>
<a name="1:12"><div class="section"><h4>12. The Parse Function</h4></a>
<p>For now, since we are focusing on single chapters, we'll make the <code>parseChapter</code> function. This
function will take three inputs: a partially constructed chapter object, the source of the chapter.
The chapter object will already have a title, a source file, and a majorNum and minorNum. The
function will return the complete chapter object. Here is an overview of the <code>parseChapter</code> function.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse function <a href="dsrc/parser.html#1:12">12</a>}</span>
<pre class="prettyprint lang-d">
Program parseProgram(Program p, string src) {
    string filename = p.file;

    string[] lines = src.split("\n");
    int lineNum;
    int majorNum;
    int minorNum;
    foreach (line; lines) {
        lineNum++;

        if (line.startsWith("@title")) {
            p.title = strip(line[6..$]);
        } else if (auto matches = matchFirst(line, regex(r"\[(?P&lt;chapterName&gt;.*)\]\((?P&lt;filepath&gt;.*)\)"))) {
            if (matches["filepath"] == "") {
                error(filename, lineNum, "No filepath for " ~ matches["chapterName"]);
                continue;
            }
            if (leadingWS(line).length &gt; 0) {
                minorNum++;
            } else {
                majorNum++;
                minorNum = 0;
            }
            Chapter c = new Chapter();
            c.file = matches["filepath"];
            c.title = matches["chapterName"];
            c.majorNum = majorNum;
            c.minorNum = minorNum;

            p.chapters ~= parseChapter(c, readall(File(matches["filepath"])));
        }
    }

    return p;
}

Chapter parseChapter(Chapter chapter, string src) {
<span class="nocode pln">    {Initialize some variables, <a href="dsrc/parser.html#1:13">13</a>}</span>

    string include(string file) {
        if (file == filename) {
            error(filename, 1, "Recursive include");
            return "";
        }
        if (!exists(file)){
            error(filename, 1, "File " ~ file ~ " does not exist");
            return "";
        }
        return readall(File(file));
    }

    // Handle the @include statements
    src = std.regex.replaceAll!(match =&gt; include(match[1]))(src, regex(`\n@include (.*)`));
    string[] lines = src.split("\n");

    int lineNum = 0;
    foreach (line; lines) {
        lineNum++;

        if (strip(line).startsWith("//") &amp;&amp; !inCodeblock) {
            continue;
        }

<span class="nocode pln">        {Parse the line, <a href="dsrc/parser.html#1:14">14</a>}</span>
    }
<span class="nocode pln">    {Close the last section, <a href="dsrc/parser.html#1:19">19</a>}</span>

    return chapter;
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:3">3</a></p>
</div>
</div>
<a name="1:13"><div class="section"><h4>13. The Parse Function Setup</h4></a>
<p>For the initial variables, it would be nice to move the value for <code>chapter.file</code> into a variable
called <code>filename</code>. Additionally, I'm going to need an array of all the possible commands that
are recognized.
</p>

<div class="codeblock">
<span class="codeblock_name">{Initialize some variables <a href="dsrc/parser.html#1:13">13</a>}</span>
<pre class="prettyprint lang-d">
string filename = chapter.file;
string[] commands = ["@code_type", "@comment_type", "@compiler", "@error_format", 
                     "@add_css", "@overwrite_css", "@colorscheme", "@include"];
</pre>
<p class="seealso">See also section <a href="dsrc/parser.html#1:13">13</a></p>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:12">12</a></p>
</div>
<p>I also need to keep track of the current section that is being parsed, and the current block that
is being parsed, because the parser is going through the file one line at a time. I'll also define
the current change being parsed.
</p>

<div class="codeblock">
<span class="codeblock_name">{Initialize some variables <a href="dsrc/parser.html#1:13">13</a>} +=</span>
<pre class="prettyprint lang-d">
Section curSection;
int sectionNum = 0;
Block curBlock;
Change curChange;
</pre>
<p class="seealso">See also section <a href="dsrc/parser.html#1:13">13</a></p>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:12">12</a></p>
</div>
<p>Finally, I need 3 flags to keep track of if it is currently parsing a codeblock, a search block,
or a replace block.
</p>

<div class="codeblock">
<span class="codeblock_name">{Initialize some variables <a href="dsrc/parser.html#1:13">13</a>} +=</span>
<pre class="prettyprint lang-d">
bool inCodeblock = false;
bool inSearchBlock = false;
bool inReplaceBlock = false;
</pre>
<p class="seealso">See also section <a href="dsrc/parser.html#1:13">13</a></p>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:12">12</a></p>
</div>
</div>
<a name="1:14"><div class="section"><h4>14. Parsing the Line</h4></a>
<p>When parsing a line, we are either inside a code block, or inside a prose block, or we are transitioning
from one to the other. So we'll have an if statement to separate the two.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse the line <a href="dsrc/parser.html#1:14">14</a>}</span>
<pre class="prettyprint lang-d">
if (!inCodeblock) {
    // This might be a change block
<span class="nocode pln">    {Parse change block, <a href="dsrc/parser.html#1:20">20</a>}</span>
<span class="nocode pln">    {Parse a command, <a href="dsrc/parser.html#1:14">14</a>}</span>
<span class="nocode pln">    {Parse a title command, <a href="dsrc/parser.html#1:14">14</a>}</span>
<span class="nocode pln">    {Parse a section definition, <a href="dsrc/parser.html#1:15">15</a>}</span>
<span class="nocode pln">    {Parse the beginning of a code block, <a href="dsrc/parser.html#1:16">16</a>}</span>
    else if (curBlock !is null) {
        if (line.split().length &gt; 1) {
            if (commands.canFind(line.split()[0])) {
                continue;
            }
        }
<span class="nocode pln">        {Add the line to the list of lines, <a href="dsrc/parser.html#1:18">18</a>}</span>
    }
} else if (startsWith(line, "---")) {
<span class="nocode pln">    {Begin a new prose block, <a href="dsrc/parser.html#1:17">17</a>}</span>
} else if (curBlock !is null) {
<span class="nocode pln">    {Add the line to the list of lines, <a href="dsrc/parser.html#1:18">18</a>}</span>
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:12">12</a></p>
</div>
<p>Parsing a command and the title command are both fairly simple, so let's look at them first.
</p>
<p>To parse a command we first make sure that there is the command name, and any arguments.
Then we check if the command is part of the list of commands we have. If it is, we
create a new command object, fill in the name and arguments, and add it to the chapter object.
</p>
<p>We also do something special if it is a <code>@include</code> command. For these ones, we take the file
read it, and parse it as a chapter (using the <code>parseChapter</code> function). Then we add the
included chapter's sections to the current chapter's sections. In this case, we don't add
the <code>@include</code> command to the list of chapter commands.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse a command <a href="dsrc/parser.html#1:14">14</a>}</span>
<pre class="prettyprint lang-d">
if (line.split().length &gt; 1) {
    if (commands.canFind(line.split()[0])) {
        Command cmd = new Command();
        cmd.name = line.split()[0];
        auto index = cmd.name.length;
        cmd.args = strip(line[index..$]);
        if (cmd.args == "none") {
            cmd.args = "";
        }

        if (curSection is null) {
            chapter.commands ~= cmd;
        } else {
            curSection.commands ~= cmd;
        }
    }
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:14">14</a></p>
</div>
<p>Parsing an <code>@title</code> command is even simpler.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse a title command <a href="dsrc/parser.html#1:14">14</a>}</span>
<pre class="prettyprint lang-d">
if (startsWith(line, "@title")) {
    chapter.title = strip(line[6..$]);
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:14">14</a></p>
</div>
</div>
<a name="1:15"><div class="section"><h4>15. Parsing a Section Definition</h4></a>
<p>When a new section is created (using <code>@s</code>), we should add the current section to the list
of sections for the chapter, and then we should create a new section, which becomes the
current section.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse a section definition <a href="dsrc/parser.html#1:15">15</a>}</span>
<pre class="prettyprint lang-d">
else if (startsWith(line, "@s")) {
    if (curBlock !is null &amp;&amp; !curBlock.isCodeblock) {
        if (strip(curBlock.text()) != "") {
            curSection.blocks ~= curBlock;
        }
    } else if (curBlock !is null &amp;&amp; curBlock.isCodeblock) {
        error(chapter.file, curBlock.startLine, "Unclosed block {" ~ curBlock.name ~ "}");
    }
    // Make sure the section exists
    if (curSection !is null) {
        chapter.sections ~= curSection;
    }
    curSection = new Section();
    curSection.title = strip(line[2..$]);
    curSection.commands = chapter.commands ~ curSection.commands;
    curSection.num = ++sectionNum;

    curBlock = new Block();
    curBlock.isCodeblock = false;
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:14">14</a></p>
</div>
</div>
<a name="1:16"><div class="section"><h4>16. Parse the Start of a Codeblock</h4></a>
<p>Codeblocks always begin with <code>--- title</code>, so we can use the regex <code>^---.+</code> to represent this.
Once a new codeblock starts, the old one must be appended to the current section's list of
blocks, and the current codeblock must be reset.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse the beginning of a code block <a href="dsrc/parser.html#1:16">16</a>}</span>
<pre class="prettyprint lang-d">
else if (matchAll(line, regex("^---.+"))) {
    if (curSection is null) {
        error(chapter.file, lineNum, "You must define a section with @s before writing a code block");
        continue;
    }

    if (curBlock !is null) {
        curSection.blocks ~= curBlock;
    }
    curBlock = new Block();
    curBlock.startLine = lineNum;
    curBlock.isCodeblock = true;
    curBlock.name = strip(line[3..$]);

    foreach (cmd; curSection.commands) {
        if (cmd.name == "@code_type") {
            curBlock.codeType = cmd.args;
        } else if (cmd.name == "@comment_type") {
            curBlock.commentString = cmd.args;
        }
    }

    inCodeblock = true;
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:14">14</a></p>
</div>
</div>
<a name="1:17"><div class="section"><h4>17. Parse the End of a Codeblock</h4></a>
<p>Codeblocks end with just a <code>---</code>. When a codeblock ends, we do the same as when it begins,
except the new block we create is a block of prose as opposed to code.
</p>

<div class="codeblock">
<span class="codeblock_name">{Begin a new prose block <a href="dsrc/parser.html#1:17">17</a>}</span>
<pre class="prettyprint lang-d">
if (curBlock !is null) {
    curSection.blocks ~= curBlock;
}
curBlock = new Block();
curBlock.startLine = lineNum;
curBlock.isCodeblock = false;
inCodeblock = false;
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:14">14</a></p>
</div>
</div>
<a name="1:18"><div class="section"><h4>18. Add the current line</h4></a>
<p>Finally, if the current line is nothing interesting, we just add it to the current block's
list of lines.
</p>

<div class="codeblock">
<span class="codeblock_name">{Add the line to the list of lines <a href="dsrc/parser.html#1:18">18</a>}</span>
<pre class="prettyprint lang-d">
curBlock.lines ~= new Line(line, filename, lineNum);
</pre>
<p class="seealso">This code is used in sections <a href="dsrc/parser.html#1:14">14</a> and <a href="dsrc/parser.html#1:14">14</a></p>
</div>
<p>Now we're done parsing the line.
</p>

</div>
<a name="1:19"><div class="section"><h4>19. Closing the last section</h4></a>
<p>When the end of the file is reached, the last section has not been closed and added to the
chapter yet, so we should do that. Additionally, if the last block is a prose block, it should
be closed and added to the section first. If the last block is a code block, it should have been
closed with <code>---</code>. If it wasn't we'll throw an error.
</p>

<div class="codeblock">
<span class="codeblock_name">{Close the last section <a href="dsrc/parser.html#1:19">19</a>}</span>
<pre class="prettyprint lang-d">
if (curBlock !is null) {
    if (!curBlock.isCodeblock) {
        curSection.blocks ~= curBlock;
    } else {
        writeln(filename, ":", lineNum - 1, ":error: {", curBlock.name, "} is never closed");
    }
}
if (curSection !is null) {
    chapter.sections ~= curSection;
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:12">12</a></p>
</div>
</div>
<a name="1:20"><div class="section"><h4>20. Parsing the change block</h4></a>
<p>Parsing a change block is somewhat complex. Change blocks look like this:
</p>
<pre><code>@change file.lit

Some comments here...

@replace
replace this text
@with
with this text
@end

More comments ...

@replace
...
@with
...
@end

...

@change_end
</code></pre><p>You can make multiple changes on one file. We've got two nice flags for keeping track of
which kind of block we are in: replaceText or searchText.
</p>

<div class="codeblock">
<span class="codeblock_name">{Parse change block <a href="dsrc/parser.html#1:20">20</a>}</span>
<pre class="prettyprint lang-d">
// Start a change block
if (startsWith(line, "@change") &amp;&amp; !startsWith(line, "@change_end")) {
    curChange = new Change();
    curChange.filename = strip(line[7..$]);
    continue;
} else if (startsWith(line, "@replace")) {
    // Begin the search block
    curChange.searchText ~= "";
    curChange.replaceText ~= "";
    inReplaceBlock = false;
    inSearchBlock = true;
    continue;
} else if (startsWith(line, "@with")) {
    // Begin the replace block and end the search block
    inReplaceBlock = true;
    inSearchBlock = false;
    continue;
} else if (startsWith(line, "@end")) {
    // End the replace block
    inReplaceBlock = false;
    inSearchBlock = false;
    // Increment the number of changes
    curChange.index++;
    continue;
} else if (startsWith(line, "@change_end")) {
    // Apply all the changes
    string text = readall(File(curChange.filename));
    foreach (i; 0 .. curChange.index) {
        text = text.replace(curChange.searchText[i], curChange.replaceText[i]);
    }
    Chapter c = new Chapter();
    c.file = curChange.filename;
    // We can ignore these, but they need to be initialized
    c.title = "";
    c.majorNum = -1;
    c.minorNum = -1;
    Chapter includedChapter = parseChapter(c, text);
    // Overwrite the current file's title and add to the commands and sections
    chapter.sections ~= includedChapter.sections;
    chapter.commands ~= includedChapter.commands;
    chapter.title = includedChapter.title;
    continue;
}

// Just add the line to the search or replace text depending
else if (inSearchBlock) {
    curChange.searchText[curChange.index] ~= line ~ "\n";
    continue;
} else if (inReplaceBlock) {
    curChange.replaceText[curChange.index] ~= line ~ "\n";
    continue;
}
</pre>
<p class="seealso">This code is used in section <a href="dsrc/parser.html#1:14">14</a></p>
</div>

</div>
</body>
